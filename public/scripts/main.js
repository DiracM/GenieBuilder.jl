let appConfig;
let currentPage;


window.onload = () => {
    console.log( "---onLoad()" );
    const queryString = window.location.search;
    const urlParams = new URLSearchParams(queryString);

    const projectId = window.projectId = urlParams.get('appid');
    const appName = window.appName = urlParams.get('appname');
    const appPath = window.appPath = urlParams.get('apppath');
    const filePath = window.filePath = urlParams.get('filepath');
    const modelName = urlParams.get('modelname');
    if( !projectId || !filePath ){
        alert( "Url should contain valid 'appid' and 'filepath' parameters" );
        return;
    }


    appConfig = {
        url: null,
        vueAppName: modelName, 
        contentScripts: [], 
        contentStyles: [], 
        template: null, 
        fileTree: null, 
        pages: null, 
        currentPage: null, 
        modelFields: [], 
        modelFieldsTypes: [], 
        grapesStyles: ''
      };
  
    ApiConnector.projectId = projectId;
    ApiConnector.getAppsList( )
    .then( (result)=>{
        console.log( "[chained] 1 apps list retrieved: ", result );
        for (let i = 0; i < result.length; i++) {
            const appInfo = result[i];
            if( appInfo.id.value == ApiConnector.projectId ){
                let pageUrl;
                if( GlobalConfig.GB_SOURCE == GlobalConfig.GB_SOURCE_LOCAL){
                    pageUrl = `${GlobalConfig.GBJL_PROTOCOL}://${GlobalConfig.GBJL_HOST}:${appInfo.port}`; 
                }else{
                    pageUrl = `${GlobalConfig.GBJL_PROTOCOL}://${GlobalConfig.GBJL_HOST}/${appInfo.port}`; 
                }
                appConfig.url = pageUrl;
                break;
            }
        }
        return ApiConnector.getProjectPages();
    })

    .then( (result)=>{
        parseAppPages(result);

        let deps = currentPage.deps;
        // PArse dependencies
        appConfig.contentStyles = [
            "https://fonts.googleapis.com/css?family=Material+Icons", 
            "css/editor-components.css"
        ];
        deps.styles.forEach( (item)=>{
         appConfig.contentStyles.push( appConfig.url + item );
        } );

      appConfig.contentScripts = [      
          "scripts/channelInject.js", 
          "./libs/jquery.min.js",
          "scripts/contentMain.js", 
      ];
      // Define a list of libraries/Assets not needed in the editor context
      // and avoid loading them to optimise newtwork/memory/cpu resources
      /* const blackList = [ "plotly", "quasar", "vueresize", "vueplotly" ];
      deps.scripts.forEach( (item)=>{
         //appConfig.contentScripts.push( appConfig.url + item );
         const scriptPath = appConfig.url + item;
         let blackListed = false;
            for (let j = 0; j < blackList.length; j++) {
                const blackListedElement = blackList[j];
                if( scriptPath.indexOf( blackListedElement ) >= 0 ){
                    blackListed = true;
                    break;
                }
            }
            if( !blackListed ){
              let myScript = document.createElement("script");
              myScript.setAttribute("src", scriptPath);
              document.body.appendChild(myScript);              
            }
        } ); */
        
        return ApiConnector.readFileContents( filePath );
    })
    .then( (fileContents)=>{
        appConfig.template = fileContents;
        window.appConfiguration = appConfig;
        window.vueAppName = appConfiguration.vueAppName;

        let grapesCssFile;
        for (let i = 0; i < currentPage.assets.length; i++) {
            const asset = currentPage.assets[i];
            if( asset.indexOf('autogenerated.css') > -1 )
            {
                grapesCssFile = asset;
                break;
            }
        }
        return ApiConnector.readFileContents( grapesCssFile );  //'public/css/autogenerated.css'
    })
    .then( (fileContents)=>{
        appConfig.grapesStyles = fileContents;

        // Check if there are unsaved changes from previous session
        // if so, ask user to restore them. Else, proceed to init editor with saved files contents
        let unsavedChanges = retrieveUnsavedChanges();
        if( unsavedChanges ){
            console.log( "Unsaved changes detected. Asking user to restore them...")
            parent.postMessage( 
                {
                  command: "askRestoreUnsavedChanges", 
                  app_id: window.projectId,
                  appName: window.appName,
                  path: window.filePath
                }, "*");
        }else{
            console.log( "No unsaved changes detected. Proceeding to init editor...")
            initNoCodeEditor();  
        }
    })
  };


  function parseAppPages(result){
    console.log( "[chained] 2 pages list retrieved: ", result );
        
        currentPage = result.filter( (page)=>{
            if( Array.isArray(page) )
                return page[0].view == filePath;
            else
                return page.view == filePath;
        } );
        // Get first (and, in theory, "only" result)
        currentPage = currentPage[0];
        // If array, get first element (the API implementation has an error here, returning
        // An array when it should be an object. This check is to ensure the right object is retrieved regardless)
        if( Array.isArray(currentPage) )
            currentPage = currentPage[0];

        let fields = currentPage.model.fields;
        let parsedFields = [];
        for (let i = 0; i < fields.length; i++) {
            let field = fields[i];
            const fieldName = field.name;
            const fieldType = field.type;
            // Discard internal fields (ending with "__")
            let isInternalVariable = field.name.endsWith("__");
            if( isInternalVariable ){
                continue;
            }
            // to-do: use a whitelist or dictionary instead of these hardcoded values
            const typeSupported = fieldType.indexOf("String") >= 0 || fieldType.indexOf("Bool") >= 0 || fieldType.indexOf("Int64") >= 0;
            let fieldObject = { name: fieldName, value:fieldName, type: fieldType, typeSupported: typeSupported };
            parsedFields.push( fieldObject );            
        }
        /* currentPage.model.fields.map( field=>{
            return { name: field, value:field };
        } ); */
        appConfig.modelFields = parsedFields;
        console.log( "[chained] 2 Current Page: ", currentPage, fields, parsedFields );

  }